<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>009 — Seasonal Garden</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0a0f; overflow: hidden; touch-action: none; font-family: 'Georgia', serif; }
canvas { display: block; }
#overlay {
  position: fixed; inset: 0; display: flex; flex-direction: column;
  align-items: center; justify-content: center; background: rgba(10,10,15,0.92);
  z-index: 10; cursor: pointer; transition: opacity 0.8s;
}
#overlay h1 { color: #c8b8a0; font-size: 2.2em; font-weight: 300; letter-spacing: 0.08em; margin-bottom: 0.4em; }
#overlay p { color: #887868; font-size: 1em; max-width: 420px; text-align: center; line-height: 1.6; }
#overlay .hint { color: #665848; font-size: 0.8em; margin-top: 1.5em; }
#season-label {
  position: fixed; top: 16px; left: 50%; transform: translateX(-50%);
  color: #887868; font-size: 0.85em; letter-spacing: 0.15em; text-transform: uppercase;
  opacity: 0.7; z-index: 5; pointer-events: none; transition: color 1s;
}
#quote {
  position: fixed; bottom: 24px; left: 50%; transform: translateX(-50%);
  color: #665848; font-size: 0.82em; max-width: 500px; text-align: center;
  font-style: italic; opacity: 0; transition: opacity 2s; z-index: 5; pointer-events: none;
}
</style>
</head>
<body>
<div id="overlay">
  <h1>Seasonal Garden</h1>
  <p>Touch the earth to plant seeds. Watch them grow through spring, resonate in summer, wither in autumn, and sleep through winter. The soil remembers what grew before.</p>
  <p class="hint">tap / click to begin</p>
</div>
<div id="season-label">spring</div>
<div id="quote"></div>
<canvas id="c"></canvas>
<script>
'use strict';

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const seasonLabel = document.getElementById('season-label');
const quoteEl = document.getElementById('quote');

let W, H;
function resize() { W = canvas.width = innerWidth; H = canvas.height = innerHeight; }
resize();
addEventListener('resize', resize);

// --- Audio ---
let audioCtx, masterGain, reverbNode, seasonDrone, droneGain, droneFilter;
let audioStarted = false;

function createReverb(ctx) {
  const conv = ctx.createConvolver();
  const len = ctx.sampleRate * 2.5;
  const buf = ctx.createBuffer(2, len, ctx.sampleRate);
  for (let ch = 0; ch < 2; ch++) {
    const d = buf.getChannelData(ch);
    for (let i = 0; i < len; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 2.8);
  }
  conv.buffer = buf;
  return conv;
}

function startAudio() {
  if (audioStarted) return;
  audioStarted = true;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.35;
  reverbNode = createReverb(audioCtx);
  reverbNode.connect(masterGain);
  masterGain.connect(audioCtx.destination);

  // Season drone
  droneGain = audioCtx.createGain();
  droneGain.gain.value = 0;
  droneFilter = audioCtx.createBiquadFilter();
  droneFilter.type = 'lowpass';
  droneFilter.frequency.value = 200;
  droneFilter.Q.value = 1;
  droneGain.connect(droneFilter);
  droneFilter.connect(reverbNode);

  seasonDrone = audioCtx.createOscillator();
  seasonDrone.type = 'sine';
  seasonDrone.frequency.value = 55;
  seasonDrone.connect(droneGain);
  seasonDrone.start();

  const sub = audioCtx.createOscillator();
  sub.type = 'sine';
  sub.frequency.value = 82.5;
  const subG = audioCtx.createGain();
  subG.gain.value = 0;
  sub.connect(subG);
  subG.connect(droneFilter);
  sub.start();
  window._subGain = subG;
}

// --- Seasons ---
const SEASONS = ['spring', 'summer', 'autumn', 'winter'];
const SEASON_COLORS = {
  spring: '#7ab87a', summer: '#d4a843', autumn: '#c45a3a', winter: '#6a8aaa'
};
const SEASON_DURATION = 18000; // 18s per season
let seasonTime = 0;
let seasonIndex = 0;
let yearCount = 0;

function currentSeason() { return SEASONS[seasonIndex]; }
function seasonProgress() { return seasonTime / SEASON_DURATION; }

// --- Soil ---
const SOIL_RES = 24;
let soil = [];
function initSoil() {
  soil = [];
  for (let y = 0; y < SOIL_RES; y++) {
    soil[y] = [];
    for (let x = 0; x < SOIL_RES; x++) {
      soil[y][x] = { hue: 30 + Math.random() * 20, nutrient: 0.1, generations: 0 };
    }
  }
}
initSoil();

function soilAt(px, py) {
  const sx = Math.floor((px / W) * SOIL_RES);
  const sy = Math.floor((py / H) * SOIL_RES);
  return soil[Math.max(0, Math.min(SOIL_RES - 1, sy))][Math.max(0, Math.min(SOIL_RES - 1, sx))];
}

function enrichSoil(px, py, hue, amount) {
  const s = soilAt(px, py);
  s.nutrient = Math.min(1, s.nutrient + amount);
  s.hue = s.hue * 0.7 + hue * 0.3; // blend toward plant's hue
  s.generations++;
}

// --- Plants ---
const plants = [];
const MAX_PLANTS = 80;
const PENTATONIC = [0, 3, 5, 7, 10]; // minor pentatonic semitones

class Plant {
  constructor(x, y) {
    const s = soilAt(x, y);
    this.x = x;
    this.y = y;
    this.baseHue = s.generations > 0 ? (s.hue + 60 + Math.random() * 40) % 360 : Math.random() * 360;
    this.inheritedNutrient = s.nutrient;
    this.size = 0;
    this.maxSize = 12 + s.nutrient * 20 + Math.random() * 8;
    this.vitality = 1;
    this.phase = 'seed'; // seed, growing, bloom, resonance, decay, dead
    this.age = 0;
    this.petals = 3 + Math.floor(Math.random() * 5);
    this.petalAngle = Math.random() * Math.PI * 2;
    this.swayOffset = Math.random() * Math.PI * 2;
    this.decayRate = 0.0003 + (1 - s.nutrient) * 0.0004; // rich soil = slower decay
    this.freq = this.calcFreq();
    this.osc = null;
    this.oscGain = null;
    this.grainTimer = 0;
    this.ghostAlpha = 0;
  }

  calcFreq() {
    const note = PENTATONIC[Math.floor((this.y / H) * PENTATONIC.length)];
    const octave = 3 + Math.floor((this.x / W) * 2);
    return 440 * Math.pow(2, (note - 9) / 12 + (octave - 4));
  }

  startSound() {
    if (!audioCtx || this.osc) return;
    this.osc = audioCtx.createOscillator();
    this.osc.type = 'sine';
    this.osc.frequency.value = this.freq;
    this.oscGain = audioCtx.createGain();
    this.oscGain.gain.value = 0;
    this.osc.connect(this.oscGain);
    this.oscGain.connect(reverbNode);
    this.osc.start();
  }

  stopSound() {
    if (this.osc) {
      this.oscGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
      const o = this.osc;
      setTimeout(() => { try { o.stop(); } catch(e){} }, 600);
      this.osc = null;
    }
  }

  playGrain() {
    if (!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = this.vitality > 0.3 ? 'triangle' : 'sawtooth';
    o.frequency.value = this.freq * (0.98 + Math.random() * 0.04);
    g.gain.value = 0;
    g.gain.linearRampToValueAtTime(0.04 * this.vitality, audioCtx.currentTime + 0.02);
    g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1 + Math.random() * 0.15);
    o.connect(g);
    g.connect(reverbNode);
    o.start();
    o.stop(audioCtx.currentTime + 0.3);
  }

  update(dt, season, sp) {
    this.age += dt;
    const sway = Math.sin(this.age * 0.001 + this.swayOffset) * 2;

    if (season === 'spring') {
      if (this.phase === 'seed' && this.age > 500) this.phase = 'growing';
      if (this.phase === 'growing') {
        this.size = Math.min(this.maxSize * 0.6, this.size + dt * 0.008 * (1 + this.inheritedNutrient));
        this.vitality = Math.min(1, this.vitality + dt * 0.0002);
      }
      if (this.phase === 'dead') {
        // rebirth from ghost if soil is rich enough
        const s = soilAt(this.x, this.y);
        if (s.nutrient > 0.3 && Math.random() < 0.001 * dt) {
          this.phase = 'growing';
          this.vitality = 0.3;
          this.size = 2;
          this.baseHue = (s.hue + 40 + Math.random() * 30) % 360;
          this.maxSize = 10 + s.nutrient * 18;
          this.freq = this.calcFreq();
          this.age = 0;
        }
      }
    } else if (season === 'summer') {
      if (this.phase === 'growing' || this.phase === 'bloom') {
        this.phase = 'bloom';
        this.size = Math.min(this.maxSize, this.size + dt * 0.003);
        if (sp > 0.5) this.phase = 'resonance';
      }
      if (this.phase === 'resonance') {
        // peak — sustained sound
        this.startSound();
        if (this.oscGain) {
          const target = 0.03 + this.vitality * 0.03;
          this.oscGain.gain.linearRampToValueAtTime(target, audioCtx.currentTime + 0.1);
        }
      }
    } else if (season === 'autumn') {
      if (this.phase === 'resonance' || this.phase === 'bloom') {
        this.phase = 'decay';
        this.stopSound();
      }
      if (this.phase === 'decay') {
        this.vitality -= this.decayRate * dt * (1 + sp);
        this.size *= (1 - 0.00005 * dt);
        // death grains
        this.grainTimer -= dt;
        if (this.grainTimer <= 0 && this.vitality > 0.05) {
          this.playGrain();
          this.grainTimer = 200 + Math.random() * 600 / (1.1 - this.vitality);
        }
        if (this.vitality <= 0) {
          this.vitality = 0;
          this.phase = 'dead';
          this.ghostAlpha = 0.5;
          enrichSoil(this.x, this.y, this.baseHue, 0.15 + this.inheritedNutrient * 0.1);
          this.stopSound();
        }
      }
    } else if (season === 'winter') {
      if (this.phase !== 'dead' && this.phase !== 'seed') {
        this.vitality -= this.decayRate * dt * 0.5;
        if (this.vitality <= 0) {
          this.vitality = 0;
          this.phase = 'dead';
          this.ghostAlpha = 0.4;
          enrichSoil(this.x, this.y, this.baseHue, 0.1);
          this.stopSound();
        }
      }
      if (this.phase === 'dead') {
        this.ghostAlpha *= (1 - 0.00008 * dt);
      }
    }

    this.drawX = this.x + sway;
  }

  draw() {
    const season = currentSeason();
    if (this.phase === 'dead') {
      if (this.ghostAlpha > 0.01) {
        ctx.globalAlpha = this.ghostAlpha * 0.4;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.maxSize * 0.3, 0, Math.PI * 2);
        ctx.fillStyle = `hsl(${this.baseHue}, 15%, 25%)`;
        ctx.fill();
        // small cross mark
        ctx.strokeStyle = `hsla(${this.baseHue}, 10%, 40%, ${this.ghostAlpha * 0.3})`;
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        ctx.moveTo(this.x - 3, this.y - 3);
        ctx.lineTo(this.x + 3, this.y + 3);
        ctx.moveTo(this.x + 3, this.y - 3);
        ctx.lineTo(this.x - 3, this.y + 3);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
      return;
    }
    if (this.phase === 'seed') {
      ctx.globalAlpha = 0.4;
      ctx.beginPath();
      ctx.arc(this.drawX, this.y, 2, 0, Math.PI * 2);
      ctx.fillStyle = `hsl(${this.baseHue}, 40%, 30%)`;
      ctx.fill();
      ctx.globalAlpha = 1;
      return;
    }

    const sat = this.phase === 'resonance' ? 70 : this.phase === 'decay' ? 30 + this.vitality * 30 : 50;
    const lit = 30 + this.vitality * 30;
    const alpha = 0.3 + this.vitality * 0.7;

    // Stem
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = `hsl(${(this.baseHue + 120) % 360}, 30%, ${20 + this.vitality * 15}%)`;
    ctx.lineWidth = 1 + this.size * 0.05;
    ctx.beginPath();
    ctx.moveTo(this.drawX, this.y + this.size * 0.5);
    ctx.lineTo(this.drawX, this.y - this.size * 0.3);
    ctx.stroke();

    // Petals
    for (let i = 0; i < this.petals; i++) {
      const angle = this.petalAngle + (Math.PI * 2 / this.petals) * i + Math.sin(this.age * 0.0008) * 0.1;
      const petalLen = this.size * 0.5 * this.vitality;
      const px = this.drawX + Math.cos(angle) * petalLen;
      const py = this.y + Math.sin(angle) * petalLen * 0.7;
      ctx.beginPath();
      ctx.ellipse(px, py, petalLen * 0.4, petalLen * 0.2, angle, 0, Math.PI * 2);
      ctx.fillStyle = `hsla(${this.baseHue + i * 8}, ${sat}%, ${lit}%, ${alpha * 0.7})`;
      ctx.fill();
    }

    // Center
    ctx.beginPath();
    ctx.arc(this.drawX, this.y, this.size * 0.15, 0, Math.PI * 2);
    ctx.fillStyle = `hsla(${this.baseHue + 30}, ${sat + 10}%, ${lit + 15}%, ${alpha})`;
    ctx.fill();

    // Resonance glow
    if (this.phase === 'resonance') {
      const glow = 0.1 + Math.sin(this.age * 0.003) * 0.05;
      ctx.globalAlpha = glow;
      ctx.beginPath();
      ctx.arc(this.drawX, this.y, this.size * 1.2, 0, Math.PI * 2);
      const grad = ctx.createRadialGradient(this.drawX, this.y, 0, this.drawX, this.y, this.size * 1.2);
      grad.addColorStop(0, `hsla(${this.baseHue}, 60%, 60%, 0.3)`);
      grad.addColorStop(1, `hsla(${this.baseHue}, 60%, 60%, 0)`);
      ctx.fillStyle = grad;
      ctx.fill();
    }

    ctx.globalAlpha = 1;
  }
}

// --- Quotes ---
const quotes = {
  spring: [
    "What died here left instructions for what comes next.",
    "The soil knows what grew before you arrived.",
    "Inheritance is not repetition — it's variation on a theme.",
    "Every spring is a hypothesis about what the earth can still support."
  ],
  summer: [
    "Resonance is the garden's way of saying: this works.",
    "Fullness is temporary. That's what makes it full.",
    "The peak is also the beginning of the end.",
    "To bloom is to commit — all resources, no hedge."
  ],
  autumn: [
    "Decay is not failure. It's the soil's next meal.",
    "The whisper at the end is not defeat — it's transmission.",
    "What falls feeds what rises.",
    "Letting go is the garden's most creative act."
  ],
  winter: [
    "Silence is not nothing. It's the space between cycles.",
    "The ground holds everything that ever grew here.",
    "Rest is not absence — it's integration.",
    "Under the stillness, the soil is working."
  ]
};
let currentQuote = '';
let quoteTimer = 0;

function showQuote(season) {
  const pool = quotes[season];
  currentQuote = pool[Math.floor(Math.random() * pool.length)];
  quoteEl.textContent = currentQuote;
  quoteEl.style.opacity = '0.6';
  quoteTimer = 6000;
}

// --- Input ---
let pointer = { x: -1, y: -1, active: false };

function plant(x, y) {
  if (plants.length >= MAX_PLANTS) {
    // remove oldest dead, or oldest
    const deadIdx = plants.findIndex(p => p.phase === 'dead');
    if (deadIdx >= 0) { plants[deadIdx].stopSound(); plants.splice(deadIdx, 1); }
    else { plants[0].stopSound(); plants.shift(); }
  }
  plants.push(new Plant(x, y));
}

function onPointer(x, y) {
  pointer.x = x; pointer.y = y; pointer.active = true;
  const season = currentSeason();
  if (season === 'spring' || season === 'summer') {
    plant(x, y);
  } else if (season === 'winter') {
    // warm the soil
    const s = soilAt(x, y);
    s.nutrient = Math.min(1, s.nutrient + 0.02);
  }
}

overlay.addEventListener('click', start);
overlay.addEventListener('touchstart', (e) => { e.preventDefault(); start(); });

function start() {
  overlay.style.opacity = '0';
  setTimeout(() => overlay.style.display = 'none', 800);
  startAudio();
}

canvas.addEventListener('mousedown', (e) => onPointer(e.clientX, e.clientY));
canvas.addEventListener('mousemove', (e) => { if (e.buttons) onPointer(e.clientX, e.clientY); pointer.x = e.clientX; pointer.y = e.clientY; });
canvas.addEventListener('mouseup', () => pointer.active = false);
canvas.addEventListener('touchstart', (e) => { e.preventDefault(); const t = e.touches[0]; onPointer(t.clientX, t.clientY); }, { passive: false });
canvas.addEventListener('touchmove', (e) => { e.preventDefault(); const t = e.touches[0]; onPointer(t.clientX, t.clientY); }, { passive: false });
canvas.addEventListener('touchend', () => pointer.active = false);

// --- Render Soil ---
function drawSoil() {
  const cellW = W / SOIL_RES;
  const cellH = H / SOIL_RES;
  for (let y = 0; y < SOIL_RES; y++) {
    for (let x = 0; x < SOIL_RES; x++) {
      const s = soil[y][x];
      if (s.nutrient > 0.05) {
        ctx.globalAlpha = s.nutrient * 0.15;
        ctx.fillStyle = `hsl(${s.hue}, 25%, 15%)`;
        ctx.fillRect(x * cellW, y * cellH, cellW, cellH);
      }
    }
  }
  ctx.globalAlpha = 1;
}

// --- Season Transition ---
function updateSeason(dt) {
  seasonTime += dt;
  if (seasonTime >= SEASON_DURATION) {
    seasonTime = 0;
    seasonIndex = (seasonIndex + 1) % 4;
    if (seasonIndex === 0) yearCount++;
    seasonLabel.textContent = currentSeason() + (yearCount > 0 ? ` · year ${yearCount + 1}` : '');
    seasonLabel.style.color = SEASON_COLORS[currentSeason()];
    showQuote(currentSeason());

    // Diffuse soil nutrients slightly between seasons
    const newSoil = soil.map(row => row.map(c => ({ ...c })));
    for (let y = 1; y < SOIL_RES - 1; y++) {
      for (let x = 1; x < SOIL_RES - 1; x++) {
        let avg = 0;
        for (let dy = -1; dy <= 1; dy++)
          for (let dx = -1; dx <= 1; dx++)
            avg += soil[y + dy][x + dx].nutrient;
        newSoil[y][x].nutrient = soil[y][x].nutrient * 0.7 + (avg / 9) * 0.3;
      }
    }
    soil = newSoil;
  }

  // Update drone based on season
  if (audioStarted) {
    const season = currentSeason();
    const sp = seasonProgress();
    let droneVol, freq, filterFreq;
    if (season === 'spring') {
      droneVol = 0.08 + sp * 0.08;
      freq = 55 + sp * 10;
      filterFreq = 150 + sp * 200;
    } else if (season === 'summer') {
      droneVol = 0.16 + Math.sin(sp * Math.PI) * 0.05;
      freq = 65;
      filterFreq = 350 + Math.sin(sp * Math.PI) * 100;
    } else if (season === 'autumn') {
      droneVol = 0.15 - sp * 0.1;
      freq = 65 - sp * 15;
      filterFreq = 350 - sp * 200;
    } else {
      droneVol = 0.03 + Math.sin(sp * Math.PI * 0.5) * 0.02;
      freq = 48;
      filterFreq = 100;
    }
    droneGain.gain.linearRampToValueAtTime(droneVol, audioCtx.currentTime + 0.1);
    seasonDrone.frequency.linearRampToValueAtTime(freq, audioCtx.currentTime + 0.3);
    droneFilter.frequency.linearRampToValueAtTime(filterFreq, audioCtx.currentTime + 0.3);
    if (window._subGain) window._subGain.gain.linearRampToValueAtTime(droneVol * 0.5, audioCtx.currentTime + 0.1);
  }
}

// --- Snow / Particles ---
const snowflakes = [];
function updateSnow(dt) {
  if (currentSeason() !== 'winter') { snowflakes.length = 0; return; }
  if (snowflakes.length < 60 && Math.random() < 0.1) {
    snowflakes.push({ x: Math.random() * W, y: -5, vx: (Math.random() - 0.5) * 0.3, vy: 0.3 + Math.random() * 0.5, size: 1 + Math.random() * 2, alpha: 0.2 + Math.random() * 0.3 });
  }
  for (let i = snowflakes.length - 1; i >= 0; i--) {
    const s = snowflakes[i];
    s.x += s.vx * dt * 0.05;
    s.y += s.vy * dt * 0.05;
    s.vx += (Math.random() - 0.5) * 0.01;
    if (s.y > H + 10) snowflakes.splice(i, 1);
  }
}

function drawSnow() {
  ctx.fillStyle = '#c8d8e8';
  for (const s of snowflakes) {
    ctx.globalAlpha = s.alpha;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

// --- Spring particles (pollen) ---
function drawPollen(dt) {
  if (currentSeason() !== 'spring') return;
  const sp = seasonProgress();
  const count = Math.floor(sp * 4);
  for (let i = 0; i < count; i++) {
    ctx.globalAlpha = 0.15 + Math.random() * 0.1;
    ctx.fillStyle = `hsl(${50 + Math.random() * 30}, 60%, 60%)`;
    ctx.beginPath();
    const px = Math.random() * W;
    const py = Math.random() * H;
    ctx.arc(px, py, 0.5 + Math.random(), 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

// --- Main Loop ---
let lastTime = 0;
function loop(t) {
  const dt = lastTime ? Math.min(t - lastTime, 50) : 16;
  lastTime = t;

  // Background — shifts with season
  const season = currentSeason();
  const sp = seasonProgress();
  let bgH, bgS, bgL;
  if (season === 'spring') { bgH = 140; bgS = 8; bgL = 5 + sp * 2; }
  else if (season === 'summer') { bgH = 45; bgS = 10; bgL = 7 + Math.sin(sp * Math.PI) * 2; }
  else if (season === 'autumn') { bgH = 20; bgS = 8; bgL = 7 - sp * 3; }
  else { bgH = 220; bgS = 5; bgL = 3 + Math.sin(sp * Math.PI * 0.5); }

  ctx.fillStyle = `hsl(${bgH}, ${bgS}%, ${bgL}%)`;
  ctx.fillRect(0, 0, W, H);

  drawSoil();
  updateSeason(dt);
  updateSnow(dt);

  for (const p of plants) p.update(dt, season, sp);
  // Sort: dead on bottom
  plants.sort((a, b) => (a.phase === 'dead' ? 0 : 1) - (b.phase === 'dead' ? 0 : 1));
  for (const p of plants) p.draw();

  drawSnow();
  drawPollen(dt);

  // Quote fade
  if (quoteTimer > 0) {
    quoteTimer -= dt;
    if (quoteTimer <= 0) quoteEl.style.opacity = '0';
  }

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
